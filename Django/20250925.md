### ORM with view

### Create
- 총 두개의 함수가 필요함
- 사용자 입력 데이터를 받을 페이지를 렌더링
- 사용자가 입력한 요청 데이터를 받아 DB에 저장

- html에서 input의 name속성은 데이터가 전해질 때의 이름이다.(키값)
- label의 for는 input의 id랑 일치시키면 label을 클릭해도 input 박스가 활성화된다.

- def create(request):
    title = request.GET.get(title)
    get 안의 title은 input에서 name=title이라고 했기 때문이다.

- noreversmatch error - url에서의 오류다.


### HTTP
- 네트워크 상에서 데이터(리소스)를 주고 받기 위한 약속

### HTTP request methods
- 데이터에 대해 수행을 원하는 작업(행동)을 나타내는 것
    - 서버에게 원하는 작업의 종류를 알려주는 역할

- 대표적인 메서드
1. GET - 리소스 조회
    - URL에 데이터가 노출됨
    - 캐싱 가능
        - 캐싱: 자주 사용하는 데이터나 결과를 임시로 저장해두고 재활용하여 처리 속도를 높이는 기술
    - 뒤로가기 기능 제공

2. POST - 데이터 생성/전송
    - 요청 본문에 데이터
    - 데이터 노출 없음

### GET Method
- 서버로부터 데이터를 요청하고 받아오는 데(조회) 사용
- 주로 검색 쿼리 전송, 웹 페이지 요청, 그리고 API에서 데이터를 조회하는 것과 같이 서버로부터 데이터를 요청하고 받아오는 데 사용됨
1. 데이터 전송
    - URL 쿼리 문자열(Query String)을 통해 데이터를 전송
2. 데이터 제한
    - URL 길이에 제한이 있어 대량의 데이터 전송에는 적합하지 않음
3. 브라우저 히스토리
    - 요청 URL이 브라우저 히스토리에 남음
4. 캐싱
    - 브라우저는 GET 요청의 응답을 로컬에 저장할 수 있음
    - 동일한 URL로 다시 요청할 때, 서버에 접소가지 않고 저장된 결과를 사용
    - 페이지 로딩 시간을 크게 단축

### POST method
- 서버에 데이터를 제출하여 리소스를 변경(생성, 수정, 삭제)하는 데 사용
- 주로 로그인 정보 제출, 파일 업로드, 새 데이터 생성, 그리고 API에서 데이터 변경을 요청하는 것과 같이 클라이언트가 서버로 데이터를 전송하여 서버의 상태를 변경할 때 사용됨
1. 데이터 전송
    - HTTP Body를 통해 데이터를 전송
2. 데이터 제한
    - GET에 비해 더 많은 양의 데이터를 전송할 수 있음
3. 브라우저 히스토리
    - POST 요청은 브라우저 히스토리에 남지 않음
4. 캐싱
    - POST 요청은 기본적으로 캐시할 수 없음
    - POST 요청이 일반적으로 서버의 상태를 변경하는 작업을 수행하기 때문

- Forbidden (403)
CSRF verification failed. Request aborted.
CSRF token missing.

### HTTP response status code
- 서버가 클라이언트의 요청에 대한 처리 결과를 나타내는 3자리 숫자
- 요청이 성공했는지, 실패했는지, 아니면 추가적인 조치가 필요한지 즉시 파악할 수 있음

- 403 Forbidden: 서버에 요청이 전달되었지만, 권한때문에 거절되었다는 것을 의미
- CSRF token missing. CSRF 토큰이 누락되었다.

### CSRF (Cross-Site-Request-Forgery) 사이트 간 요청 위조
- 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행동(글쓰기, 정보 수정, 송금 등)을 특정 웹사이트에 요청하게 만드는 해킹 방식

- CSRF(위조된 인감도장)
1. 신뢰할 수 있는 관계(로그인)
    - 사용자는 은행에 정상적으로 로그인하여, 은행은 사용자를 신뢰하고 있다는 증표(세션 쿠키)를 브라우저에 발급. 이 쿠키가 바로 당신의 '인감도장'
2. 악성 위임장(악성 링크)
    - 사기꾼(해커)은 "무료 경품 이벤트"와 같은 미끼 링크를 사용자에게 보냄. 이 링크의 실제 내용은 '내 돈 100만원을 해커에게 송금하라'는 내용이 담긴, 당신의 인감도장만 찍으면 되는 '위조된 위임장'
3. 나도 모르는 날인(요청 전송)
    - 사용자가 미끼 링크를 클릭하는 순간, 당신의 브라우저는 자기도 모르게 은행에 외조된 위임장(송금 요청)을 보냄. 이때 브라우저는 은행에 보낼때마다 인감도장(세션 쿠키)을 자동으로 찍어서 보냄
4. 은행의 착각(공격 성공)
    - 은행 입장에서는 정상적인 인감도장이 찍힌 위임장이 도착했으므로, 이 요청이 당신의 진짜 의사라고 믿고 송금을 실행

- Django는 이러한 공격을 막기 위해 CSRF 토큰이라는 안전장치 사용
- 모든 중요한 요청에 대해 "내가 직접 보낸 요청이 맞다"는 일회용 비밀 코드를 함께 보내도록 하여 위조된 요청을 막아줌.

- POST는 단순 조회(GET)와 달리 리소스의 변경(생성, 수정, 삭제)을 요청하는 의미와 기술적 특성을 지님
- DB에 조작을 가하는 요청은 반드시 인증 수단이 필요

## Redirect
- HTTP 표준 관점
- POST 요청은 데이터 생성/변경에 사용되며, 동일 요청이 반복되면 안됨
- 현재 방식에선 사용자가 완료 페이지에서 새로고침 시 중복 게시물 작성의 위험이 있음

- 사용자 경험(UX) 관점
- 작성 완료 후 완료 페이지를 직접 응답하는 방식은 직관적이지 않고, 사용자가 예상하는 흐름과 다름
- 브라우저의 페이지 기록 관리와 상태 관리에 혼란을 줄 수 있음

- 서버는 데이터 저장 후 페이지를 응답하는 것이 아닌 사용자를 적절한 기존 페이지로 보내야 한다.
- 사용자를 보낸다 -> 사용자가 GET 요청을 한번 더 보내도록 한다.
- 실제로 서버가 클라이언트를 직접 다른 페이지로 보내는 것이 아닌 클라이언트가 GET 요청을 한번 더 보내도록 응답하는 것

- redirect(): 클라이언트가 인자에 작성된 주소로 다시 요청을 보내도록 하는 함수

### redirect 동작 원리
1. redirect 응답을 받은 클라이언트는 detail url로 다시 요청을 보내게 됨
2. 결과적으로 detail view 함수가 호출되어 detail view 함수의 반환 결과인 detail 페이지를 응답받게 되는 것
- -> 결국 사용자는 게시글 작성 후 작성된 게시글의 detail 페이지로 이동하는 것으로 느끼게 됨

1. [POST] 게시글 작성 요청(+입력 데이터)
2. create view 함수 호출
3. redirect 응답(detail 주소로 요청을 보내라)
4. [GET] detail 페이지 요청
5. detail view 함수 호출
6. detail 페이지 응답

### Delete


### Update
- 사용자 입력 데이터를 받을 페이지를 렌더링
- 사용자가 입력한 요청 데이터를 받아 DB에 저장