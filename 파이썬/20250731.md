## 상속(Inheritance)
- 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려받는 것
- 부모 클래스와 자식 클래스 간의 상하 관계가 형성되고, 위쪽에 있는 부모 클래스가 본인의 속성과 메서드를 아래쪽에 있는 자식에게 넘겨주는 것

### 상속이 필요한 이유
1. 코드 재사용
    - 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
    - 기존 클래스를 수정하지 않고도 기능을 확장할 수 있음
2. 계층 구조
    - 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
    - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
3. 유지 보수의 용이성
    - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
    - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음

```python
class Animal:
    def eat(self):
        print('먹는 중')

class Dog(Animal):
    def bark(self):
        print('멍멍')

my_dog = Dog()
my_dog.bark() #멍멍

# 부모 클래스(Animal) 메서드 사용 가능
my_dog.eat() # 먹는 중
```

### 메서드 오버라이딩(Method Overriding)
- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의하는 것
- 자식 클래스에서 메서드를 다시 정의하면, 부모 클래스의 메서드 대신 자식 클래스의 메서드가 실행됨
- 오버라이딩은 동일한 이름과 매개변수를 사용하지만, 내부 동작을 원하는 대로 바꿀 수 있게 해줌
- 부모 클래스의 기능을 유지하면서도 일부 동작을 맞춤형으로 바꾸고 싶을 때 유용하다

```python
class Animal:
    def eat(self):
        print('Animal이 먹는 중')

class Dog(Animal):
    # 부모 클래스(Animal)의 eat 메서드를 재정의(오버라이딩)
    def eat(self):
        print('Dog가 먹는중')

my_dog = Dog()
my_dog.eat() # Dog가 먹는 중
```
- 파이썬은 **오버로딩(Overloading)을 지원하지 않는다!**
- 마지막으로 선언된 메서드만 인식함

## 다중 상속
- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있습니다.
- 상속받은 모든 클래스의 요소를 활용 가능합니다.
- 중복된 속성이나 메서드가 있는 경우 **상속 순서에 의해 결정**됩니다.

```python
class Person:
    def __init__(self, name):
        self.name = name

    def greeting(self):
        return f'안녕, {self.name}'

class Mom(Person):
    gene = 'XX'

    def swim(self):
        return '엄마가 수영'

class Dad(Person):
    gene = 'XY'

    def walk(self):
        return '아빠가 걷기'

class FirstChild(Dad, Mom):
    def swin(self):
        return '첫째가 수영'

    def cry(self):
        return '첫째가 응애'

baby1 = FirstChild('아가')
print(baby1.cry()) # 첫째가 응애
print(baby1.swim()) # 첫째가 수영
print(baby1.walk()) # 아빠가 걷기
print(baby1.gene) # XY => Dad 클래스를 먼저 작성했기 때문에 class FirstChild(Dad,Mom)
```
### 다이아몬드 문제(The diamond problem)
- 두 클래스 B와C가 A에서 상속되고 클래스 D가 B와 C 모두에서 상속될 때 발생하는 모호함
- B와 C가 재정의한 메서드가 A에 있고 D가 이를 재정의 하지 않은 경우라면
- D는 B의 메서드 중 어떤 버전을 상속하는가?
아니면 C의 메서드 버전을 상속하는가?

### 파이썬에서의 해결책
- MRO(Method Resolution Order) 알고리즘을 사용하여 클래스 목록을 생성
- 부모클래스로부터 상속된 속성을 정해진 내부 알고리즘에 따라 검색
- 이 순서는 기본적으로 왼쪽에서 오른쪽으로 진행되며, 계층 구조에서 중복되는 클래스는 한 번만 확인
- 그래서, 속성이 D에서 발견되지 않으면, B에서 찾고, 거기에서도 발견되지 않으면, C에서 찾고, 이런 식으로 진행됨

### MRO
- 파이썬이 메서드를 찾는 순서에 대한 규칙 메서드 결정 순서
- 다중 상속에서 어떤 부모 클래스의 메서드를 먼저 사용할지 순서를 정의
- 미리 정해진 MRO를 통해 다중 상속 환경에서도 예측 가능한 방식으로 메서도 탐색이 이루어질 수 있도록 함

### super() 함수
- 메서드 해석 순서(MRO)에 따라, 현재 클래스의 부모(상위) 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장 함수
- super()를 사용하면 직접 부모 클래스 이름을 적지 않아도 MRO에 따라 자동으로 올바른 메서드를 찾아 실행할 수 있음
- 다중 상속에서 suepr()를 호출하면 상속 순서에 맞춰 여러 부모 클래스의 메서드를 순차적으로 실행할 수 있음
- 생성자나 오버라이딩된 메서드에서 super()를 호출하면 보무 클래스의 초기화나 로직을 그대로 활용 가능

```python
class ParentA:
    def __init__(self):
        self.value_a = 'ParentA'
    
    def show_value(self):
        print(f'Value from ParentA: {self.value_a}')

class ParentB:
    def __init__(self):
        self.value_b = 'ParentB'
    
    def show_value(self):
        print(f'Value from ParentB: {self.value_b}')

class Child(ParentA, ParentB):
    def __init__(self):
        super().__init__() # ParentA 클래스의 __init__ 메서드 호출
        self.value_c = 'Child'
    def show_value(self):
        super().show_value() # ParentA 클래스의 show_value 메서드 호출
        print(f'Value from Child: {self.value_c}')

child = Child()
child.show_value()
"""
Value from ParentA: ParentA
Value from Child: Child
"""
print(child.value_c) # Child
print(child.value_a) # ParentA
```
- ClassName.\__mro__ 또는 ClassName.mro()를 확인해 MRO 순서를 파악한 뒤 적절히 활용하는 연습을 하면, 보다 복잡한 상속 구조에서도 코드를 잘 관리할 수 있음

# 에러와 예외
## 디버깅
### 버그
- 소프트웨어에서 발생하는 오류 또는 결함
- 프로그램의 예상된 동작과 실제 동작 사이의 불일치

### 디버깅
- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정
- 프로그램의 오작동 원인을 식별하여 수정하는 작업

### 디버깅 방법
1. print 함수 활용
    - 특정 함수 결과, 반복/조건 결과 등 나눠서 생각, 코드를 bisection으로 나눠서 생각
2. 개발 환경(text editior, IDE) 등에서 제공하는 기능 활용
    - breakpoint, 변수 조회 등
3. Python tutor 활용 (단순 파이썬 코드인 경우)
4. 뇌 컴파일, 눈 디버깅 등

## 에러
- 프로그램 실행 중에 발생하는 예외 상황
- 문법 에러(Syntax Error)
    - 프로그램의 구문이 올바르지 않은 경우 발생(오타, 괄호 및 콜론 누락 등의 문법적 오류)
- 예외(Exception)
    - 프로그램 실행 중에 감지되는 에러

### 예외(Exception)
- 프로그램 실행 중에 감지되는 에러
- 프로그램이 잘못된 동작을 시도할 때 자동으로 감지됨
- 이런 상황을 처리하지 않으면 프로그램은 즉시 종료됨

### 내장 예외(Built-in Exceptions)
- 예외 상황을 나타내는 예외 클래스들
- 내장 예외는 파이썬에서 이미 정의되어 있으며, 특정 예외 상황에 대한 처리를 위해 사용
1. ZeroDivisionError: 나누기 또는 모듈로 연산의 두 번째 인자가 0일 때 발생
2. NameError: 지역 또는 전역 이름을 찾을 수 없을 때
3. TypeError: 타입 불일치
4. TypeError: 인자 누락
5. TypeError: 인자 초과
6. TypeError: 인자 타입 불일치
7. ValueError: 연산이나 함수에 문제가 없지만 부적절한 값을 가진 인자를 받았고, 상황이 IndexError처럼 더 구체적인 예외로 설명되지 않는 경우 발생
8. IndexError: 시퀀스 인덱스가 범위를 벗어남
9. KeyError: 딕셔너리에 해당 키가 존재하지 않는 경우
10. ImportError: import하려는 이름을 찾을수 없을 때
11. ModuleNotFoundError: 모듈을 찾을 수 없을 때
12. KeyboardInterrupt: 사용자가 Control_C 또는 Delete를 누를 때 발생
13. IndentationError: 잘못된 들여쓰기와 관련된 문법 오류

### 예외 처리(Exception Handling)
- 예외가 발생했을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록 하는 방법

### 예외처리 사용 구문
- try
    - 예외가 발생할 수 있는 코드 작성
- except
    - 예외가 발생했을 때 실행할 코드 작성
- else
    - 예외가 발생하지 않았을 때 실행할 코드 작성
- finally
    - 예외 발생 여부와 상관없이 항상 실행할 코드 작성

### try-except 구조
```python
try:
    result = 10 / 0
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')

try:
    num = int(input('숫자입력 : '))
except ValueError:
    print('숫자가 아닙니다.')
"""
숫자입력 : a
숫자가 아닙니다.
"""
```

### 복수 예외 처리
```python
try:
    num = int(input('100으로 나눌 값을 입력하시오 : '))
    print(100 / num)
except (ValueError, ZeroDivisionError):
    print('제대로 입력해주세요.')

try:
    num = int(input('100으로 나눌 값을 입력하시오 : '))
    print(100 / num)
except ValueError:
    print('숫자를 넣어주세요')
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except:
    print('에러가 발생하였습니다.')
```
### else & finally
- else 블록은 예외가 발생하지 않았을 때 추가 작업을 진행
- finally 블록은 예외 발생 여부와 상관없이 항상 실행할 코드를 작성

```python
try:
    x = int(input('숫자를 입력하세요: '))
    y = 10 / x
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except ValueError:
    print('유효한 숫자가 아닙니다.')
else:
    print(f'결과: {y}')
finally:
    print('프로그램이 종료되었습니다.')
```
## 참고
### 예외 처리 주의사항
```python
try:
    num = int(input('100으로 나눌 값을 입력하시오 : '))
    print(100 / num)
except Exception: # 여기서 모든 Error가 걸려버린다.
    print('숫자를 넣어주세요.')
# ZeroDivisionError는 Exception의 하위 클래스이므로 Exception보다 먼저 작성해야 함
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except:
    print('에러가 발생하였습니다.')
----------------------------------
try:
    num = int(input('100으로 나눌 값을 입력하시오 : '))
    print(100 / num)
# 1) 구체적인 예외부터
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except ValueError:
    print('숫자를 넣어주세요.')
# 2) 마지막에 광범위한 예외(Exception)
except Exception:
    print('에러가 발생하였습니다.')

```

### 예외 객체 다루기
- as 키워드
    - 예외객체 : 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
    - except 블록에서 예외 객체를 받아 상세한 예외 정보를 활용 가능
```python
my_list = []
try:
    number = my_list[1]
except IndexError as error:
    print(f'{error}가 발생했습니다.')
# list index out of range가 발생했습니다
```
- try-except와 if-else를 함께 사용할 수 있음
```python
try:
    x = int(input('숫자를 입력하세요: '))
    if x < 0:
        print('음수는 허용되지 않습니다.')
    else:
        print('입력한 숫자:', x)
except ValueError:
    print('오류 발생')
```

### EAFP & LBYL
- EAFP(Easier to Ask for Forgiveness than Permission)
    - 예외처리를 중심으로 코드를 작성하는 접근 방식(try-except)
- LBYL(Look before you Leap)
    - 값 검사를 중심으로 코드를 작성하는 접근 방식(if-else)