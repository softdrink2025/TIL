# 비시퀀스 데이터 구조
## 딕셔너리
- 키(Key)와 값(Value)을 짝지어 저장하는 자료 구조
- 딕셔너리는 내부적으로 **해시 테이블**을 사용하여 키-값을 관리함
- 키를 통한 값의 삽입, 삭제, 검색이 데이터의 크기와 관계없이 매우 빠름
- 키(Key)는 hashable한 **고유 값**이어야 하지만, 값(Value)은 중복이 가능하고 어떤 자료형도 저장할 수 있음

### 딕셔너리 메서드
|메서드|설명|
|:---:|:---:|
|D.get(k)|키 k에 연결된 값을 반환 (키가 없으면 None 반환)|
|D.get(k, v)|키 k에 연결된 값을 반환하거나 키가 없으면 기본으로 값으로 v를 반환|
|D.keys()|딕셔너리 D의 키를 모은 객체를 반환|
|D.values()|딕셔너리 D의 값을 모은 객체를 반환|
|D.items()|딕셔너리 D의 키/값 쌍을 모은 객체를 반환|
|D.pop(k)|딕셔너리 D에서 키 k를 제거하고 연결됐던 값을 반환 (없으면 오류)|
|D.pop(k, v)|딕셔너리 D에서 키 k를 제거하고 연결됐던 값을 반환 (없으면 v를 반환)|
|D.clear()|딕셔너리 D의 모든 키/값 쌍을 제거|
|D.setdefault(k)|딕셔너리 D에서 키 k와 연결된 값을 반환|
|D.setdefault(k, v)|딕셔너리 D에서 키 k와 연결된 값을 반환</br>k가 D의 키가 아니면 값 v와 연결한 키 k를 D에 추가하고 v를 반환|
|D.update(other)|other 내 각 키에 대해 D에 있는 키면 D에 있는 그 키의 값을 other에 있는 값으로 대체.</br>other에 있는 각 키에 대해 D에 없는 키면 키/값 쌍을 D에 추가|



### .get(key[, default])
- 키 연결된 값을 반환하거나 키가 없으면 None 혹은 기본 값을 반환
```python
person = {'name': 'Doremi', 'age': 25}
print(person.get('name')) # Doremi
print(person.get('major')) # None
print(person.get('major', '해당 키는 존재하지 않습니다.'))
print(person['name']) # Doremi
print(person['major']) # KeyError: 'major'

# .get 과 그냥 []의 차이 - 키가 없다면 생기는 에러의 유무
# 상황에 맞춰서 쓰면 된다.
```

### .keys()
- 딕셔너리 키를 모은 객체를 반환
```python
person = {'name': 'Doremi', 'age': 25}
print(person.keys()) # dict_keys(['name', 'age'])
for item in person.keys():
    print(item)
"""
name
age
"""
# dict_keys() 객체
person = {'name': 'Doremi', 'age': 25}
person_keys = person.keys()
person['major'] = 'computer'
print(person.keys()) # dict_keys(['name', 'age', 'major'])
# dict_keys - 실시간으로 동기화되는 확인 창(view)
```

### .values()
- 딕셔너리 값을 모은 객체를 반환
```python
person = {'name': 'Doremi', 'age': 25}
print(person.values()) # dict_values(['Alice', 25])
for item in person.values():
    print(item)
"""
Doremi
25
"""
```

### .items()
- 딕셔너리 키/값 쌍을 모은 객체를 반환
```python
person = {'name': 'Doremi', 'age': 25}
print(person.items()) # dict_items([('name', 'Alice'), ('age', 25)])
for key, value in person.items():
    print(key, value)
"""
name Alice
age 25
"""
```

### .pop(key[, default])
- 키를 제거하고 연결됐던 값을 반환 (없으면 에러나 default를 반환)
```python
person = {'name': 'Doremi', 'age': 25}
print(person.pop('age')) # 25
print(person) # {'name': 'Doremi'}
print(person.pop('major', None)) # None
print(person.pop('major')) # KeyError
```
### .clear()
```python
person = {'name': 'Doremi', 'age': 25}
person.clear()
print(person) # {}
```

### .setdefault(key[,default])
- 키와 연결된 값을 반환
- 키가 없다면 default와 연결한 키를 딕셔너리에 **추가**하고 default를 반환
- get 기능 + 추가
```python
person = {'name': 'Doremi', 'age': 25}
print(person.setdefault('major', 'computer')) #'computer'
print(person) # {'name': 'Doremi', 'age': 25, 'major': 'computer'}
```

### .update([other])
- other가 제공하는 키/값 쌍으로 딕셔너리를 갱신하고 기존 키는 덮어씀
```python
person = {'name': 'Doremi', 'age': 25}
other_person = {'name': 'ABC', 'major': 'computer'}

person.update(other_person)
print(person) # {'name': 'ABC', 'age': 25, 'major': 'computer'}
              # Alice가 지워짐

person.update(age=100, address='Seoul') # {'name': 'ABC', 'age': 100, 'major': 'computer', 'address': 'Seoul'}
```
## 세트
- 고유한 항목들의 정렬되지 않은 컬렉션
- Set는 내부적으로 해시 테이블을 사용하여 데이터를 저장함
- 수학적인 집합 연산을 간편하게 수행할 수 있음

### 세트 메서드
|메서드|설명|
|:---:|:---:|
|s.add(X)|세트 s에 항목 x를 추가. 이미 x가 있다면 변화 없음|
|s.update(iterbale)|세트 s에 다른 iterable 요소를 추가|
|s.clear()|세트 s의 모든 항목을 제거|
|s.remove(x)|세트 s에서 항목 x를 제거. 항목 x가 없을 경우 Key error|
|s.pop()|세트 s에서 임의의 항목을 반환하고, 해당 항목을 제거|
|s.discard(x)|세트 s에서 항목 x를 제거|

### .add(x)
- 세트에 x를 추가
```python
my_set = {'a', 'b', 'c', 1, 2, 3}

my_set.add('d')
print(my_set) # {1, 2, 3, 'd', 'a', 'b', 'c'}

my_set.add('d')
print(my_set) # {1, 2, 'b', 3, 'a', 'd', 'c'}
```

### .update(iterable)
- 세트에 다른 iterable 요소를 추가
```python
my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.update([1, 4, 5])
print(my_set) # {'b', 1, 2, 'c', 3, 4, 5, 'a'}

my_set.update({'name': 'Doremi'})
print(my_set) # {'a', 1, 2, 3, 4, 5, 'b', 'c', 'name'}

```
### .clear()
- 세트의 모든 항목을 제거
```python
my_set = {'a', 'b', 'c', 1, 2, 3}

my_set.clear()
print(my_set) # set()
```

### .remove(x)
- 세트에서 항목 x를 제거, 항목 x가 없을 경우 keyError
```python
my_set = {'a', 'b', 'c', 1, 2, 3}

my_set.remove(2)
print(my_set) # {'c', 1, 3, 'b', 'a'}

my_set.remove(10) # KeyError: 10
```

### .pop()
- 세트에서 **임의의** 요소를 제거하고 반환
- 무작위가 아니다!!

```python
my_set = {'a', 'b', 'c', 1, 2, 3}

element = my_set.pop()
print(element) # 1
print(my_set) # {2, 3, 'b', 'a', 'c'}
```

### .discard(x)
- 세트 s에서 항목 x를 제거. remove와 달리 **에러 없음**
```python
my_set = {'a', 'b', 'c', 1, 2, 3}

my_set.discard(2)
print(my_set) # {1, 3, 'b', 'a', 'c'}

my_set.discard(10) # 에러 없음
```

### 세트의 집합 메서드
|메서드|설명|연산자|
|:---:|:---:|:---:|
|set1.difference(set2)|set1에는 들어있지만 set2에는 없는 항목으로 세트 생성 후 반환|set1 - set2|
|set1.intersection(set2)|set1과 set2 모두 들어있는 항목으로 세트를 생성 후 반환|set1 & set2|
|set1.issubset(set2)|set1의 항목이 모두 set2에 들어있으면 True를 반환|set1 <= set2|
|set1.issuperset(set2)|set1가 set2의 항목을 모두 포함하면 True를 반환|set1 >= set2|
|set1.union(set2)|set1 또는 set2에(혹은 둘 다) 들어있는 항목으로 세트를 생성 후 반환|set1 \| set2|

# 참고

## 해시 테이블(hast table)
- 해시 테이블은 '키(Key)'와 '값(Value)'을 짝지어 저장하는 자료구조

### 해시 테이블의 원리
1. 키를 해시 함수를 통해 해시 값으로 변환
2. 변환된 해시 값을 인덱스로 삼아 데이터를 저장하거나 찾음
3. 이로 인해 검색, 삽입, 삭제를 매우 빠르게 수행

### 해시(Hash)
- 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것
- 생성된 해시 값(고유한 정수)은 해당 데이터를 식별하는 '지문' 역할을 함
- 파이썬에서는 이 해시 값을 이용해 해시 테이블에 데이터를 저장
- 이 변환을 수행하는 것이 해시 함수

### 해시 함수(Hash Function)
- 임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해 주는 함수. 이 '정수'가 바로 해시 값
- '해시 알고리즘'이라고도 부름
- 해시 함수는 키를 입력받아 데이터를 저장하거나 찾을 배열의 정확한 인덱스를 즉시 계산함

### set의 요소 & dict의 키와 해시 테이블 관계
- set
    - 각 요소를 해시 함수로 변환해 나온 해시 값에 맞춰 해시 테이블 내부 버킷(bucket)에 위치시킴
    - 그래서 "순서"라기보다 "버킷 위치(인덱스)"가 요소의 위치를 결정
    - 따라서 set는 순서를 보장하지 않음
- dict
    - 키(key) -> 해시 함수 -> 해시 값 -> 해시 테이블에 저장
    - 단 set와 달리 "삽입 순서"는 유지한다는 것이 언어 사양에 따라 보장 됨(python 3.7 이상)
        - 즉, 키를 추가한 순서대로 반복문 순회할 때 나오게 됨
        - 사용자에게 보여지는 키 순서는 삽입 순서가 유지되도록 설계된 것

- set 의 pop()은 "임의의 요소"를 제거하고 반환함
    - 실행할 때마다 다른 요소를 얻는다는 의미에서 "무작위"가 아니라 "임의"라는 의미에서의 "무작위"(By "arbitrary" the docs don't mean "random")

### 파이썬에서의 해시 함수
- 정수
    - 정수(숫자) 값은 해시 값이 숫자 자기 자신과 동일하거나 단순 계산으로 고정됨
    - 같은 정수는 항상 같은 해시 값을 가짐
    - 예) hash(1)은 여러 번 호출해도 결과가 동일
- 문자열
    - 문자열은 해시 계산 시 파이썬의 해시 난수화가 적용되므로, 실행마다 순서가 달라질 수 있음
    - 문자열 해시 시, 파이썬 인터프리터 시작 때 설정되는 난수시드(seed)가 달라질 수 있음
    - 보안상 이유로 해시 난수화 도입
    - 각 실행마다 달라질 수 있어 'a'의 해시 값도 매번 바뀔 수 있음

### hashable
- hash() 함수에 넣어 해시 값을 구할 수 있는 객체를 의미
- 대부분의 불변 타입은 해시 가능
    예) int, float, str, tuple(단, 내부에 불변만 있을 경우)
- 가변형 객체(예:list, dict, set)는 기본적으로 해시 불가능
    - 이유: 값이 변하면 해시 값도 달라질 수 있어 해시 테이블 무결성이 깨

### 파이썬 문법
- EBNF "Extended Backus-Naur Form"