## 데이터 구조
- 여러 데이터를 효과적으로 사용, 관리하기 위한 구조 (str, list, dict 등)

## 자료 구조
- 컴퓨터 공학에서는 '자료 구조'라고 함
- 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠 놓은 것
- 단순히 데이터를 묶는 것을 넘어, 프로그램의 성능과 효율성, 유지보수성에 큰 영향을 미치는 핵심적인 개념

## 메서드
- 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 메서드를 호출하여 다양한 기능을 활용하기
- 객체에 속한 함수
    - 프로그래밍에서 메서드는 객체가 특정 작업을 수행하도록 정의된 함수
- 클래스(class) 내부에 저장되는 함수
- 클래스는 파이썬에서 '타입을 표현하는 방법'이며 이미 은연중에 사용해왔음

### 메서드 호출 방법
- 데이터 타입 객체.매서드()
- 혼자서 쓰일 수 없고 반드시 객체가 필요함
```python
'hello'.capitalize()
  객체      매서드

# 문자열 메서드 예시
print('hello'.capitalize()) # Hello

# 리스트 메서드 예시
numbers = [1, 2, 3]
numbers.append(4)

print(numbers) # [1, 2, 3, 4]
```

## 시퀀스 데이터 구조
### 문자열
|메서드|설명|
|:---:|:---:|
|s.find(x)|x의 첫 번째 위치를 반환. 없으면 -1을 반환|
|s.index(x)|x의 첫 번째 위치를 반환. 없으면, 오류 발생|
|s.isupper()|문자열 내의 모든 문자가 대문자인지 확인|
|s.islower()|문자열 내의 모든 문자가 소문자인지 확인|
|s.isalpha()|문자열 내의 모든 문자가 알파벳인지 확인</br>(단순 알파벳이 아닌 유니코드 상 Letter(한국어도 포함))|

### 문자열 조작 메서드(새로운 문자열 반환)
- 대괄호 안에 있는 것은 선택 인자라는 뜻. 대괄호를 쓴다는 말은 아니다!

|메서드|설명|
|:---:|:---:|
|s.replace(old, new[,count])|바꿀 대상 글자를 새로운 글자로 바꿔서 반환|
|s.strip([chars])|공백이나 특정 문자를 제거|
|s.split(sep=None, maxsplit=-1)|sep를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 반환|
|'separator'.join(iterable)|구분자로 iterable의 문자열을 연결한 문자열을 반환|
|s.capitalize()|가장 첫 번째 글자를 대문자로 변경|
|s.title()|문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자로, 나머지는 소문자로 변환|
|s.upper()|모두 대문자로 변경|
|s.lower()|모두 소문자로 변경|
|s.swapcase()|대 <-> 소문자 서로 변경|

#### .replace(old, new[,count])
바꿀 대상 글자를 새로운 글자로 바꿔서 반환

#### .strip([chars])
문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거
```python
print('eleven'.split('e'))    # leven
print('eleven'.split('en'))   # lev
print('eleven'.split('env'))  # l
# 순서 상관없이 각 문자가 들어가면 다 없어짐

lstrip(), rstrip()
```
#### .split(sep=None, maxsplit=-1)
문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거
```python
text = '    Hello, world!    '
new_text = text.strip()
print(new_text)  # 'Hello, world!'
```

#### 'separator'.join(iterbale)
iterable의 문자열을 연결한 문자열을 반환
```python
words =["I'm", "hungry!"]
text = '-'.join(words)
text2 = ''.join(words)

print(text) # "I'm-hungry!"
print(text2) # I'mhungry!
```

### 리스트

### 리스트 값 추가 및 삭제 메서드
- 리스트 메서드는 보통 반환값이 없다

|메서드|설명|
|:---:|:---:|
|L.append(x)|리스트 마지막에 항목 x를 추가|
|L.extend(m)|iterable m의 모든 항목들을 리스트 끝에 추가(+=과 같은 기능)|
|L.insert(i, x)|리스트 인덱스 i에 항목 x를 삽입|
|L.remove(x)|리스트 가장 왼쪽에 있는 항목(첫번째) x를 제거</br>항목이 존재하지 않을 경우, ValueError|
|L.pop()|리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거|
|L.pop(i)|리스트의 인덱스 i에 있는 항목을 반환 후 제거|
|L.clear()|리스트의 모든 항목 삭제|

### .append(x)
- .append(1,3) 등 인자에 여러개 넣으면 에러가 난다
    - TypeError: list.append() takes exactly one argument
- append는 None을 반환한다.
    - print(my_list.append(5)) # None

### .extend(m)
- 반복 가능한 객체가 아니면 추가 불가
    - TypeError: 'int' object is not iterable
```python
# extend
my_list = [1, 2, 3]
my_list.extend([4, 5, 6])
print(my_list)  # [1, 2, 3, 4, 5, 6]

# extend와 append의 비교
my_list.append([5, 6, 7])
print(my_list)  # [1, 2, 3, 4, 5, 6, [5, 6, 7]]
```

### .insert(i, x)
- 리스트의 지정한 인덱스 i위치에 항목 x를 삽입

```python
my_list = [1, 2, 3]
my_list.insert(1, 5)
print(my_list) # [1, 5, 2, 3]
```
### .remove(x)
- 리스트에서 첫 번째로 일치하는 항목을 삭제
```python
my_list = [1, 2, 3, 2, 2, 2]
my_list.remove(2)
print(my_list) # [1, 3, 2, 2, 2]
```

### .pop(i)
- 리스트에서 지정한 인덱스의 항목을 제거하고 **반환**
- 작성하지 않을 경우 마지막 항목을 제거

```python
my_list = [1, 2, 3, 4, 5]
item1 = my_list.pop()
item2 - my_list.pop(0)
print(item1) # 5
print(item2) # 1
print(my_list) # [2, 3, 4]
```

### .clear()
- 리스트의 모든 항목을 삭제
```python
my_list [1, 2, 3]
my_list.clear()
print(my_list) # []
```

### 리스트 탐색 및 정렬 메서드
|메서드|설명|
|:---:|:---:|
|L.index(x)|리스트에서 첫 번째로 일치하는 항목 x의 인덱스를 반환|
|L.count(x)|리스트에서 항목 x의 개수를 반환|
|L.reverse()|리스트의 순서를 역순으로 변경(정렬X)|
|L.sort()|리스트를 정렬 (매개변수 이용가능)|

### .index(x)
- 리스트에서 첫 번째로 일치하는 항목 x의 인덱스를 반환
```python
my_list = [1, 2, 3]
index = my_list.index(2)
print(index) # 1
```

### .count(x)
- 리스트에서 항목 x의 개수를 반환

```python
my_list = [1, 2, 2, 3, 3, 3]
count = my_list.cont(3)
print(count) # 3
```

### .reverse()
- 리스트의 순서를 역순으로 변경(정렬X)
 ```python
 my_list = [1, 3, 2, 8, 1, 9]
 my_list.reverse()
 # print(my_list.reverse()) # None
 print(my_list) # [9, 1, 8, 2, 3, 1]
```

### .sort()
- 원본 리스트를 오름차순으로 정렬
```python
my_list = [3, 2, 100, 1]
my_list.sort()
# sort는 None을 반환합니다.
# print(my_list.sort())  # None
print(my_list) # [1, 2, 3, 100]

# 내림차순 정렬
my_list.sort(reverse=True)
print(my_list) # [100, 3, 2, 1]
```
## 복사

### 변수 할당의 의미
- 파이썬에서 변수 할당은 객체애 대한 참조를 생성하는 과정
    - 변수는 객체의 메모리 주소를 가리키는 Label 역할을 함
    - '='연산자를 사용하여 변수에 값을 할당
        - 할당 시 새로운 객체가 생성되거나 기존 객체에 대한 참조가 생성됨

#### 가변 객체 예시
- 생성 후 변경할 수 있는 객체
```python
a = [1, 2, 3, 4]
b = a
b[0] = 100

print(a) # [100, 2, 3, 4]
print(b) # [100, 2, 3, 4]
print(a is b) # True
```

#### 가변 객체 예시
- 생성후 내용을 변경할 수 없는 객체
```python
a = 20
b = a
b = 10

print(a) # 20
print(b) # 10
print(a is b) # False
```

### 얕은 복사
- 객체의 최상위 요소만 새로운 메모리에 복사하는 방법
- 내부에 중첩된 객체가 있다면 그 객체의 참조만 복사됨
1. 리스트 슬라이싱
```python
a = [1, 2, 3]
b = a[:]

print(a) # [1, 2, 3]
prnit(b) # [1, 2, 3]

더 해보기
a[0] = 10
print(b) # ?
a = [1, 2, 3, 4]
b = a[1:4]


# 새로운 리스트에 복사되는 것은 요소 자체의 값이 아니라 해당 요소들이 참조하는 주소다.
```
2. list()함수
```python
a = [1, 2, 3]
d = list(a) # list() 함수를 사용하여 a의 얕은 복사본 생성

# 원본 리스트 a의 첫 번째 요소 변경 (1차원 리스트의 경우 얕은 복사로 충분히 독립적인 복사본을 만들 수 있음)
a[0] = 100

print(a) # [100, 2, 3]
print(d) # [1, 2, 3]

# 얕은 복사가 보이게 
a = [[1, 2], [3, 4]]
d = list(a)  # 얕은 복사

a[0][0] = 999  # 내부 리스트 수정

print(a)  # [[999, 2], [3, 4]]
print(d)  # [[999, 2], [3, 4]] ← 얘도 바뀜!
```
- 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우
```python
a = [1, 2, [3, 4, 5]]
b = a[:]

b[0] = 999
prnit(a) # [1, 2, [3, 4, 5]]
print(b) # [999, 2, [3, 4, 5]]

b[2][1] = 100
print(a) # [1, 2, [3, 100, 5]]
print(b) # [999, 2, [3, 100,5 ]]

print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}') # True
```

### 깊은 복사
- 객체의 모든 수준의 요소를 새로운 메뫼에 복사하는 방법
- 중첩된 객체까지 모두 새로운 객체로 생성됨

```python
import copy
new_object = copy.deepcopy(original_object)

a = [1, 2, [3, 4, 5]]
b = copy.deepcopy(a)

b[2][1] = 100

print(a) # [1, 2, [3, 4, 5]]
print(b) # [1, 2, [3, 100, 5]]
print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}') # False
```

## List Comprehension

## 메서드 체이닝 (Method Chaining)
- 여러 메서드를 연속해서 호출하는 방식

## 문자 유형 판별 메서드
- isdecimal()
    - 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
- isdigit()
    - isdecimal()과 비슷하지만, 유니코드 숫자도 인식
- isnumeric()
    - isdigit()과 유사하지만, 몇 가지 추가적인 유니코드 문자들을 인식
    ( 분수, 지수, 루트 기호도 숫자로 인식)
