# stack 1-2
- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조

### Fucntion Call
- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행순서 관리

- 시스템 스택
    - 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 저장함
    - 함수 호출이 발생하면 스택 프레임(stack frame)에 저장하여 시스템 스택에 삽입

### 재귀 호출
- 함수가 자신과 같은 작업을 반복해야 할 때, 자신을 다시 호출하는 구조

### 메모이제이션(Memoization)
- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술
```python
# Memoization을 적용한 피보나치
def fibo1(n):
    if n >=2 and memo[n] == 0:
        memo[n] = fibo1(n-1) + fibo(n-2)
    return memo[n]
memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
```

### 동적계획법(DP, Dynamic Programming)
- 입력 크기가 작은 부분 문제들을 먼저 해결한 뒤, 그 결과를 바탕으로 더 큰 부분 문제를 순차적으로 해결해 나가며 최종적으로 전체 문제의 해답을 도출하는 알고리즘

- DP 적용 문제
    - 문제의 최적 해가 그 하위 문제의 최적 해로부터 쉽게 구성될 수 있는 최적 부분구조여야 함
    - 동일한 하위 문제가 여러 번 반복되어 나타나는 중복 부분 문제여야 함
```python
def fibo2(n):
    f = [0] * (n + 1)
    f[0] = 0
    f[1] = 1
    for i in range(2, n+1):
        f[i] = f[i-1] + f[i-2]

    return f[n]
```

### 깊이 우선 탐색(DFS, Depth First Search)
- 한 방향으로 가능한 깊게 탐색한 후, 더 이상 갈 곳이 없으면 되돌아와 다른 방향을 탐색
- 동작 원리
    - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 나간다.
    - 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 탐색방법
    - 후입선출(LIFO) 구조의 스택 사용
```python
# visitied[], stack[] 초기화
DFS(v)
    시작점 v 방문;
    visited[v] <- true;
    while:
        if (v의 인접 정점 중 방문 안 한 정점 w가 있으면)
            push(v);
            v <M- w; (w에 방문)
        visited[w] <- truw;
        else
            if (스택이 비어 있지 않으면)
                v <- pop(stack);
                else
                    break

                    