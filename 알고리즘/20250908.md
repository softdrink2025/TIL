# 완전검색/그리디
### 집합에서 부분 집합을 찾아내는 구현 방법
1. 완전 탐색
    - 재귀호출을 이용한 완전탐색으로, 부분 집합을 구할 수 있음.
    - 실전보다는 완전 탐색 학습용으로 추천하는 방법
2. Binary Counting
    - 2진수 & 비트연산을 이용하여, 부분 집합을 구할 수 있음.
    - 모든 부분 집합이 필요할 때 사용하는 추천 방법

```python
# 리스트의 더하기
# 위와 아래의 id 주소값이 다르다
arr = [1, 2, 3]
arr = arr + [4]

# 위와 아래의 id 주소값이 같다
arr = [1, 2, 3]
arr += [4]
```

### Binary Counting
```python
def get_sub(tar):
    print(f'target = {tar}', end=" ")
    for i in range(len(arr)):
        # 0x1로 표기한 이유(1, 0b1, 0b0001, True 다 된다)
        # => 비트 연산임을 명시하는 권장 방법
        if tar & 0x1:  # 가장 우측 비트를 체크
            print(arr[i], end=' ')
        tar >>= 1

```

### 조합
```python
def recur(cnt, start):
    # N명을 뽑으면 종료
    if cnt == N:
        print(*path)
        return
    
    for i in range(start, len(arr)):
        path.append(arr[i])
        # i번째를 골랐으니, 다음 선택은 i부터 고려 (중복을 허용하는 조합)
        # recur(cnt + 1, i)
        recur(cnt + 1, i + 1)  # i번째를 골랐으니, 다음은 i + 1 부터 고려
                               # 중복을 허용하지 않는 조합
        path.pop()
```

### Greedy 탐욕 알고리즘
- 그리디로 풀 수 있는가?
1. 탐욕적 선택 조건 (Greedy Choice Property)
- 각 단계의 최적해 선택이 이후 단계 선택에 영향을 주지 않는다.
- 즉, 각 단계 규칙이 변경되면 안된다.

2. 최적 부분 구조 (Optimal Substructure)
- 각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이 되어야 함
- => 증명을 통해 해결
- 동전 문제 예시
    - [명제] 가장 큰 동전부터 고르면 최소 동전 수가 나온다.
    - [간접 증명]
        - 최적해보다 더 적은 동전으로 표현 가능하다. (가정)
        - -> N원을 더 작은 값의 동전으로 도 작은 수로 할 수 있다.
            - ==> 동전이 배수로 있기 때문에 안됨
            - ==> 더 적은 값으로 나누면 무조건 더 큰 수가 나옴