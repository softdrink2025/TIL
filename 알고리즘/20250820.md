# Queue 1-1

### 큐 Queue
- 먼저 들어온 데이터가 먼저 나가는 선형 자료구조

### 선입선출 FIFO(First In First Out)
- 가장 먼저 넣은 자료가 가장 먼저 나오는 것

### 큐의 기본 연산
- 머리(Front): 저장된 원소 중 첫 번째 원소(또는 삭제된 위치)
- 꼬리(Rear): 저장된 원소 중 마지막 원소
- 삽입: enqueue
- 삭제: dequeue
- enqueue(item): 큐의 뒤쪽(rear 다음)에 원소를 삽입하는 연산
- dequeue(): 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
- create_queue(): 공백 상태의 큐를 생성하는 연산
- is_empty(): 큐가 공백상태인지를 확인하는 연산
- is_full(): 큐가 포화상태인지를 확인하는 연산
- qpeek(): 큐의 앞쪽(front)에서 원소를 삭제 없이 반환하는 연산

### 큐의 연산 과정
1. 공백 큐 생성: create_queue(), front = rear = -1
2. 원소 A 삽입: enqueue(A) rear += 1
3. 원소 B 삽입: enqueue(B) rear += 1
4. 원소 반환/삭제: dequeue()  front += 1  # front는 삭제된 위치
5. 원소 C 삽입: enqueue(C) rear += 1
6. 원소 반환/삭제: dequeue() front += 1
7. 원소 반환/삭제: dequeue() front += 1
   front == rear 라면 queue가 비어있다는 것이다.

### 선형 큐(Linear Queue)
- 데이터를 일렬로 저장하며, 앞에서 꺼내고 뒤에 넣는 기본 큐 구조
- 구현
    - 배열이나 연결형 리스트로 구현할 수 있음
    - 큐의 크기는 배열의 크기와 같음
    - front: 가장 최근에 삭제된 원소의 인덱스
    - rear: 마지막으로 저장된 원소의 인덱스

- 상태 표현
    - 초기 상태: front = rear = -1
    - 공백 상태: front == rear
    - 포화 상태: rear == n-1 (n: 배열의 크기, n-1: 배열의 마지막 인덱스)

```python
# 초기 공백 큐 생성. 크기가 n인 1차원 배열
def create_queue(n):  # 대충짜는 코드임 참고용
    q = [0] * n
    front = -1
    rear = -1

# 삽입
def enqueue(item):
    global rear
    if is_full():
        print("Queue_Full")
    else:
        rear += 1
        q[rear] = item

# 삭제
def dequeue():
    if (is_empty()) then queue_empty()
    else:
        front += 1
        return q[front]

# 공백상태 및 포화상태 검사
def is_empty():
    return front == rear

def is_full():
    return rear == len(q) - 1 

# 검색
def qpeek():
    if is_empty():
        print("Queue_Empty")
    else:
        return q[front+1]

## 입력과 출력
front = rear = -1
q = [0] * 10

rear += 1  # enq(1)
q[rear] = 1 
rear += 1  # enq(2)
q[rear] = 2
rear += 1  # enq(3)
q[rear] = 3

front += 1  # deq()
print(q[front])
front += 1  # deq()
print(q[front])
front += 1  # deq()
print(q[front])
```

### 원형 큐(Circular Queue)
- 선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고, rear = n = 1인 상태 즉, 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 된다
- 선형 큐의 공간 낭비를 막기 위해 처음과 끝이 연결된 구조

### 원형 큐의 구조
- 초기 공백 상태
    - front = rear = 0
- index의 순환
    - front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨다
    - 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동
    - 이를 위해 나머지 연산자 mod를 사용
- front 변수
    - 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠

- 선형 큐와 원형 큐 비교

||삽입 위치|삭제 위치|
|:---:|:---:|:---:|
|선형 큐|rear = rear + 1|front = front + 1|
|원형 큐|rear = (rear + 1) mod n| front = (front + 1) mod n|

### 원형 큐의 구현
```python
# 대충 개념만 보는 코드임
# 초기 공백 큐 생성
cq = [0] * n
front = rear = 0

# 삽입: enqueue(item)
def enqueue(item):
    global rear
    if is_full():
        print("Queue_Full")
    else:
        rear = (rear + 1) % len(cq)
        cq[rear] = item

# 삭제
def dequeue():
    global front
    if is_empty():
        print("Queue_Empty")
    else:
        front = front(front + 1) % len(cq)
        return cq[front]

# 공백 상태 및 포화 상태 검사 is_empty(), is_full()
def is_empty():
    return front == rear

def is_full():
    return (rear + 1) % len(cq) == front
```
### 연결 큐(Linked Queue)
- 연결 리스트를 이용해 구현한 큐


### 연결 큐의 구조
- 단순 연결 리스트(Linked List)를 이용한 큐
    - 큐의 원소: 단순 연결 리스트의 노드
    - 큐의 원소 순서: 노드의 연결 순서, 링크로 연결되어 있음
    - front: 첫 번째 노드를 가리키는 링크
    - rear: 마지막 노드를 가리키는 링크

- 상태 표현
    - 초기 상태: front = rear = null
    - 공백 상태: front = rear = null

### deque(덱)
- 컨테이너 자료형 중 하나로 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너
    - 연결 리스트를 직접 만들지 않아도 됨
- append(x): 오른쪽에 x 추가
- popleft(): 왼쪽에서 요소를 제거하고 반환. 요소가 없으면 IndexError

### 우선순위 큐(priority Queue)
- 우선순위를 가진 항목들을 저장하는 큐
- 배열을 이용하여 자료 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
- 가장 앞에 최고 우선순위의 원소가 위치하게 됨
- 문제점
    - 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치 발생
    - 이에 소요되는 시간이나 메모리 낭비가 큼

### 버퍼(Buffer)
- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
- 버퍼를 채우는 것을 버퍼링이라고 함
