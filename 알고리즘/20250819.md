# Stack 2-2

### 부분집합(powerset)
- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분
- 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 수는 2**n개이다.

### Backtracking 기법으로 powerset 만들기
- 앞에서 설명한 일반적인 Backtracking 접근 방법을 이용
- N개의 원소가 들어있는 집합의 2**n 개의 부분집합을
    - True 또는 False 값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용
- 여기서 배열의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값

```python
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i                  # 0번째 원소
    for j in range(2):
        bit[1] = j              # 1번째 원소
        for k in range(2):
            bit[2] = k          # 2번째 원소
            for l in range(2):  
                bit[3] = l      # 3번째 원소
                print(bit)      # 생성된 부분집합 출력

# Powerset을 구하는 Backtracking 알고리즘 1
def backtrack(a, k, n):  # a 주어진 배열, k 결정할 원소, n 원소 개수
    c = [0] * MAXCANDIDATES  # 후보군 저장

    if k == n:
        process_solution(a, k)  # 답이면 원하는 작업을 한다
    else:
        ncandidates = construct_candidates(a, k, n, c)  # 후보 수

        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k+1, n)


def construct_candidaters(a, k, n, c):
    c[0] = True
    c[1]=  True
    retunre 2

def process_solution(a, k):
    for i in range(k):
        if a[i]:
            print(nun[i], end=' ')
    print()
```

### 순열
``` python
def backtrack(a, k, n):
    c = [0] * MAXCANDIDATES

    if k == n:
        for i in range(0,k):
            print(a[i], end=" ")
        print()
    else:
        ncandidates = construct_candidates(a, k, n, c)

        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k+1, n)

def construct_candidates(a, k, n, c):
    in_perm = [False] * (NMAX + 1)

    for i in range(k):
        in_perm[a[i]] = True

    ncandidates = 0
    for i in range(1, NMAX + 1):
        if in_perm[i] == False:
            c[ncandidates] = i
            ncandidates += 1
    return ncandidates
```

### 가지치기
```python
def f(i, N):  # bit[i]를 결정하는 함수
    if i == N:
        print(bit)
    else:
        bit[i] = 1
        f(i + 1, N)
        bit[i] = 0
        f(i + 1, N)
```

### 순열 2