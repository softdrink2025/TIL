# List 2-2

## 부분집합
- 부분집합 생성하기
    - 완전검색 기법으로 부분집합 합 문제 풀기
        - 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산함
    - 주어진 집합의 부분집합을 생성하는 방법?

- 부분집합의 수
    - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2**n개
    - 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같음

```python
def print_subset(bit):
    for i in range(4):
        if bit[i]:  # bit[i]가 0이 아니면
            print(arr[i], end=' ')
        print()

bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i  # 0번 원소
    for j in range(2):
        bit[1] = j  # 1번 원소
        for k in range(2):
            bit[2] = k  # 2번 원소
            for l in range(2):
                bit[3] = l   # 3번 원소
                print_subset(bit)  # 생성된 부분집합 출력
# 실전에서는 다른 방법을 씀
```
### 비트 연산자
- &: 비트 단위로 AND 연산
- |: 비트 단위로 OR 연산
- <<: 피연산자의 비트 열을 왼쪽으로 이동
- \>>: 피연산자의 비트 열을 오른쪽으로 이동

- 연산자 활용
    - 1 << n: 2 ** n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미
    - i & (1 << j): i의 j번째 비트가 1인지 아닌지를 검사

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)
for i in range(1 << n):
    for j in range(n):
        if i & (1 << j):
            print(arr[j], end=", ")
    print()
print()
# print(f'{i:b}') 하면 이진수로 출력된다
```

## 검색(Search)
- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
- 목적하는 탐색 키를 가진 항목을 찾는 것
- 탐색 키(Search Key): 자료를 구별하여 인식할 수 있는 키

### 순차 검색
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
    - 가장 간단하고 직관적인 검색 방법
    - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용
    - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적임
- 정렬 여부에 따라
    - 순차 검색 대상이 정렬되어 있지 않은 경우
    - 순차 검색 대상이 정렬되어 있는 경우

### 정렬되어 있지 않는 경우 순차 검색
1. 첫 번쨰 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
2. 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
3. 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패
```python
def search(a, n, key):
    for i in range(n):
        if key == a[i]:
            return i
    return -1
```
- 평균 비교 횟수 = (n+1)/2
- 검색 실패시 = n
- 시간 복잡도: O(n)

### 정렬되어 있는 경우
- 검색 실패를 반환하는 경우에도 평균 비교 회수가 (n+1)/2
- 시간 복잡도: O(n)

### 이진 검색(Binary Search)
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    - 목적키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행
- 이진 검색을 하기 위해서는 자료가 **정렬된 상태**여야 함
```python
def binarySearch(a, N, key):  # key를 찾으면 인덱스, 실패하면 -1 반환
    start = 0
    end = N - 1
    while start <= end:
        middle = (start + end) // 2
        if a[middle] == key:  # 검색 성공
            return middle
        elif a[middle] > key:  # 찾는 값보다 크면
            end = middle - 1  # 왼쪽 구간 선택
        else:
            start = middle + 1  # 오른쪽 구간 선택
    return -1
```

### 선택 정렬
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식 (오름차순의 경우)
- 정렬과정
    1. 주어진 리스트 중에서 최소값을 찾기
    2. 그 값을 리스트의 맨 앞에 위치한 값과 교환
    3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복

- 시간 복잡도: O(n**2)
```python
def selection_sort(a, N):
    for i in range(N-1):  # 정렬 구간의 시작 인덱스
        min_idx = i  # 첫 원소를 최소로 가정
        for j in range(1+1, N):
            if a[min_idx] > a[j]:  # 최소 원소 위치 갱신
                min_idx = j
        a[i], a[min_idx] = a[min_idx], a[i]  # 구간 최솟값을 구간 맨 앞으로
```

### 셀렉션 알고리즘
- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
    - 최솟값, 최댓갑 혹은 중간값을 찾는 알고리즘을 의미하기도 함
- 선택 과정
    - 정렬 알고리즘 이용하여 자료 정렬하기
    - 원하는 순서에 있는 원소 가져오기