# String 2

## 연산

### 회문
- "기러기", "토마토", "스위스"와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 문장이나 낱말
- 문자열 길이의 반만 비교하면 된다

### 문자열 비교
- == 연산자, if 연산자
- == 연산자는 내부적으로 특수메서드 __eq__()를 호출함

### 사전 순서 비교
- 비교 연산자 < 사용
    - 유니코드를 비교

### 문자열 숫자를 숫자로 변환
```python
# 문자열을 숫자로 변환
a = int('123')
b = float('3.14')
c = int('A0, 16')  # 문자열 'A0'를 16진법으로 해석해서 변환
# 숫자를 문자열로 변환
a = str(123)
b = str(3.14)
```
## 고지식한 패턴 검색
### 고지식한 알고리즘(Brute Force)
- 단순한 방법
    - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식
```python
def brute_force(p, t):  # p 찾을 패턴, t 본문 문자열
    i = 0  # t의 인덱스
    j = 0  # p의 인덱스
    M = len(p)
    N = len(t)
    while j < M and i < N:
        if t[i] != p[j]:
            i = i - j  # 같아서 다음 글자도 비교했던 경우 비교 시작 위치로
            j = -1  # j값 초기화
        i = i + 1  # 다음 문자 비교
        j = j + 1  # 다음 문자 비교
    if j == M:
        return i - M  # 검색 성공
    else:
        return -1  # 검색 실패 
```

### KMP 알고리즘
- 연구자인 Knuth, Morris, Pratt 세 사람의 이름에서 유래
- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
    - 불일치가 발생했을 경우 이동할 다음 위치를 계산하는 전처리가 필요
- 시간 복잡도
    - 패턴의 길이가 M일 때 전처리에 걸리는 시간은 O(M)
    - 텍스트의 길이가 N일 때 검색은 최악의 경우 O(N)
    - 결과적으로 O(M+N)

- LPS(Longest Prefix which is also Suffix) 배열
    - 접두사이자 접미사인 문자열의 최대 길이
    - 일치하지 않을 때 비교할 인덱스
    - 구현에 따라 next, pi 배열로도 불림

### 보이어-무어(Boyer-Moore) 알고리즘
- 상용 소프트웨어에서 채택하고 있는 알고리즘
- 실제 검색에서 매우 빠른 성능
    - 패턴 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이만큼이 된다.

- 불일치 문자 휴리스틱(Bad-Character Heuristic)
    - 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재할 경우
        - 불일치 문자 오른쪽에서 일치한 부분을 고려해 점프

### 문자열 암호화
- 시저 암호(Caesar cipher)
    - 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 [평행이동] 시킴으로써 암호화

- 문자 변환표를 이용한 암호화(단일 치환 암호화)