## 스프링 애플리케이션의 핵심 계층 구조
- 전체적인 흐름은 Controller -> Service -> DAO(Repository) -> Database 순서로 진행되며, 이 과정에서 데이터를 주고받기 위해 DTO와 Entity라는 객체를 사용

## Controller
- 역할: 사용자의 요청(HTTP Request)을 가장 먼저 받는 곳
- 기능: 요청에 담긴 파라미터를 읽고, 어떤 서비스(Service) 기능을 실행할지 결정한 뒤 결과를 반환
- 특징: 비지니스 로직을 직접 구현하지 않고, 서비스 계층으로 넘겨주는 '교환원'역할에 집중해야 함

# DTO (Data Transfer Object, 전달자)
- 역할: 계층 간(예: Controller <-> Service) 데이터를 전달하기 위해 사용하는 객체
- 기능: 화면에서 필요한 데이터만 골라 담거나, 보안상 중요한 정보(비밀번호 등)를 제외하고 데이터를 전달할 때 사용
- 특징: 오직 데이터를 담기 위한 바구니이므로 로직을 포함하지 않음

## Service (핵심 로직)
- 역할: 실제 비지니스 로직이 수행되는 곳
- 기능: "비밀번호가 일치하는가?", "재고가 남아있는가?" 같은 검증과 계산을 수행
- 특징: 하나의 서비스 기능은 하나의 트랜잭션(Transaction)단위로 관리되는 경우가 많음

## DAO (Data Access Object, 창고 관리자)
- 역할: 데이터베이스(DB)에 직접 접근하여 데이터를 저장하거나 조회하는 객체
- 기능: SQL을 시행하여 DB와 소통
- 참고: 최근 스프링 부트(Spring Data JPA)에서는 DAO 대신 Repository라는 인터페이스를 사용하여 더 간단하게 구현

## Entity (DB 테이블 그 자체)
- 역할: 실제 DB 테이블과 1:1로 매핑되는 클래스입니다.
- 주의: DTO와 비슷해 보이지만, Entity는 DB의 핵심 모델이므로 화면에 전달하는 용도로 직접 사용하지 않는 것이 원칙(DTO를 거쳐서 전달)

## 데이터의 이동 흐름(예: 회원가입)
- Client: 아이디/비번 입력 후 가입 버튼 클릭
- Controller: 가입 요청 수신 -> 데이터를 SingUpDTO에 담아 Service로 전달
- Service: "아이디 중복 확인" 등 로직 수행 -> DTO를 Entity로 변환하여 Repository(DAO)에 전달
- Repository: Entity를 기반으로 DB에 INSERT 쿼리 실행
- DB: 데이터 저장 완료

## 이렇게 나누어 관리하는 이유(분리하는 이유)
- 유지보수 용이성: DB 주소나 쿼리가 바뀌어도 DAO(Repository)만 수정하면 되고, 화면이 바뀌어도 Controller만 수정하면 됨
- 보안: Entity를 직접 화면에 노출하면 DB 구조가 드러나 위험함. DTO를 통해 필요한 정보만 선택해서 보여줌
- 테스트: 각 계층이 분리되어 있어 특정 부분만 떼어내어 오류를 찾기 쉬움